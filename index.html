<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursos: Rust Distribuido & Docker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .resource-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .resource-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="bg-[#FDFCFB] text-slate-800 font-sans min-h-screen">

    <!-- Chosen Palette: Sand & Slate (Neutros cálidos para enfoque y calma) -->
    <!-- Application Structure Plan: 
         La aplicación se ha reestructurado como un "Knowledge Hub" o repositorio centralizado.
         1. Header Informativo: Contexto sobre la infraestructura de 3 nodos/9 contenedores.
         2. Buscador y Filtros: Interactividad para navegar por tipo de recurso (Documentación, Video, Tutorial).
         3. Grid de Referencias: Colección exhaustiva de enlaces técnicos reales con justificación de uso.
         4. Glosario Técnico: Definiciones rápidas para los conceptos clave del proyecto.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <div class="max-w-6xl mx-auto px-6 py-12">
        
        <!-- Header Section -->
        <header class="mb-16 border-b border-slate-200 pb-10">
            <h1 class="text-4xl font-bold text-slate-900 mb-4">Recursos para Algoritmos Distribuidos en Rust</h1>
            <p class="text-lg text-slate-600 max-w-3xl">
                Esta biblioteca contiene las referencias técnicas fundamentales para implementar el procesamiento distribuido en tu infraestructura de 
                <span class="text-orange-700 font-semibold">3 computadoras y 9 contenedores Docker</span>. 
                Los recursos están seleccionados específicamente para abordar la comunicación sobre VPN y la concurrencia en Rust.
            </p>
        </header>

        <!-- Search & Filter Section -->
        <div class="mb-10 flex flex-col md:flex-row md:items-center justify-between gap-6">
            <div class="relative flex-grow max-w-md">
                <input type="text" id="searchInput" placeholder="Buscar tecnología (ej. Docker, Redis, Async)..." 
                       class="w-full px-4 py-3 rounded-lg border border-slate-200 focus:ring-2 focus:ring-orange-500 focus:outline-none transition-all">
            </div>
            <div class="flex gap-2 flex-wrap" id="filterContainer">
                <button class="filter-btn px-4 py-2 rounded-full text-sm font-medium bg-slate-800 text-white" onclick="filterData('Todos')">Todos</button>
                <button class="filter-btn px-4 py-2 rounded-full text-sm font-medium bg-slate-200 text-slate-600 hover:bg-slate-300" onclick="filterData('Documentación')">Documentación</button>
                <button class="filter-btn px-4 py-2 rounded-full text-sm font-medium bg-slate-200 text-slate-600 hover:bg-slate-300" onclick="filterData('Video')">Videos</button>
                <button class="filter-btn px-4 py-2 rounded-full text-sm font-medium bg-slate-200 text-slate-600 hover:bg-slate-300" onclick="filterData('Crate/Librería')">Librerías (Crates)</button>
                <button class="filter-btn px-4 py-2 rounded-full text-sm font-medium bg-slate-200 text-slate-600 hover:bg-slate-300" onclick="filterData('Tutorial')">Tutoriales</button>
            </div>
        </div>

        <!-- Resources Grid -->
        <main id="resourceGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-20">
            <!-- Los elementos se inyectan dinámicamente mediante JavaScript -->
        </main>

        <!-- Tech Stack Context -->
        <section class="bg-slate-100 rounded-2xl p-8 border border-slate-200">
            <h2 class="text-2xl font-bold text-slate-900 mb-6">Glosario de Implementación</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                    <h3 class="font-bold text-orange-800 mb-2">Infraestructura VPN (Tailscale/ZeroTier)</h3>
                    <p class="text-sm text-slate-600">Fundamental para que tus 3 computadoras se vean como una red local segura. Rust se conectará a las IPs virtuales (10.x.x.x) ignorando los firewalls físicos.</p>
                </div>
                <div>
                    <h3 class="font-bold text-orange-800 mb-2">Orquestación (Docker Swarm/Compose)</h3>
                    <p class="text-sm text-slate-600">Para desplegar los 9 contenedores (3 por nodo) de forma idéntica, asegurando que el binario de Rust tenga las mismas variables de entorno en cada host.</p>
                </div>
                <div>
                    <h3 class="font-bold text-orange-800 mb-2">Serialización (Serde + Bincode)</h3>
                    <p class="text-sm text-slate-600">Al enviar datos pesados por la red, JSON es lento. Se recomienda Bincode para transformar estructuras de Rust a binario con mínima sobrecarga.</p>
                </div>
                <div>
                    <h3 class="font-bold text-orange-800 mb-2">Runtime (Tokio)</h3>
                    <p class="text-sm text-slate-600">El estándar para sistemas distribuidos en Rust. Permite que cada contenedor maneje la comunicación de red sin bloquear el procesamiento del algoritmo.</p>
                </div>
            </div>
        </section>

        <footer class="mt-20 text-center text-slate-400 text-sm">
            <p>Guía de Referencia para Computación Distribuida en Rust &bull; 2024</p>
        </footer>
    </div>

    <script>
        // Base de datos de recursos
        const resources = [
            {
                category: "Video",
                title: "Crust of Rust: Async/Await & Tokio",
                author: "Jon Gjengset",
                desc: "Explicación profunda de cómo funciona el modelo de concurrencia de Rust, vital para coordinar múltiples nodos.",
                link: "https://www.youtube.com/watch?v=Th3vSvtkgT4",
                tags: ["async", "tokio", "network"]
            },
            {
                category: "Documentación",
                title: "Bastion: El Framework de Actores",
                author: "Bastion Project",
                desc: "Librería diseñada para sistemas distribuidos altamente disponibles que se auto-reparan si un contenedor falla.",
                link: "https://bastion.rs/",
                tags: ["distribuido", "tolerancia-fallos", "actores"]
            },
            {
                category: "Crate/Librería",
                title: "Redis-rs (Colas de Trabajo)",
                author: "Mitsuhiko",
                desc: "La mejor forma de implementar la estrategia de colas para tus 9 trabajadores usando un servidor Redis central.",
                link: "https://github.com/redis-rs/redis-rs",
                tags: ["redis", "queue", "database"]
            },
            {
                category: "Tutorial",
                title: "Docker Swarm: Cluster de 3 Nodos",
                author: "Docker Official",
                desc: "Guía para unir tus 3 máquinas físicas en un solo cluster lógico para desplegar tus contenedores.",
                link: "https://docs.docker.com/engine/swarm/swarm-tutorial/",
                tags: ["docker", "infraestructura", "swarm"]
            },
            {
                category: "Documentación",
                title: "Zenoh: Protocolo para VPN y Edge",
                author: "Eclipse Zenoh",
                desc: "Protocolo de comunicación ultra-eficiente que supera a MQTT/HTTP en redes VPN y entornos distribuidos.",
                link: "https://zenoh.io/",
                tags: ["comunicación", "vpn", "baja-latencia"]
            },
            {
                category: "Crate/Librería",
                title: "Rayon: Paralelismo de Datos",
                author: "Rayon Team",
                desc: "Para que cada uno de tus 9 contenedores aproveche todos los núcleos locales de su CPU asignada.",
                link: "https://github.com/rayon-rs/rayon",
                tags: ["paralelismo", "cpu", "performance"]
            },
            {
                category: "Video",
                title: "Distributed Rust en Producción",
                author: "InfoQ / Luca Palmieri",
                desc: "Conferencia sobre los desafíos reales de mover datos entre servicios Rust en clusters de contenedores.",
                link: "https://www.infoq.com/presentations/rust-distributed-systems/",
                tags: ["arquitectura", "producción"]
            },
            {
                category: "Tutorial",
                title: "gRPC con Tonic en Rust",
                author: "Tonic Project",
                desc: "Cómo implementar comunicación tipo RPC (Remote Procedure Call) de alta velocidad entre tus nodos.",
                link: "https://github.com/hyperium/tonic",
                tags: ["grpc", "comunicación", "http2"]
            },
            {
                category: "Documentación",
                title: "Bincode: Serialización Binaria",
                author: "Bincode Org",
                desc: "Formato de serialización optimizado para Rust. Mucho más rápido que JSON para enviar datos por la VPN.",
                link: "https://github.com/bincode-org/bincode",
                tags: ["serialización", "performance", "binario"]
            }
        ];

        let currentFilter = 'Todos';

        function renderResources(data) {
            const grid = document.getElementById('resourceGrid');
            grid.innerHTML = '';

            data.forEach(res => {
                const card = document.createElement('article');
                card.className = "resource-card bg-white border border-slate-200 rounded-xl p-6 flex flex-col justify-between";
                
                const tagHtml = res.tags.map(tag => 
                    `<span class="text-[10px] bg-slate-100 text-slate-500 px-2 py-0.5 rounded uppercase font-bold tracking-wider">${tag}</span>`
                ).join(' ');

                card.innerHTML = `
                    <div>
                        <div class="flex justify-between items-start mb-4">
                            <span class="text-xs font-bold text-orange-600 px-2 py-1 bg-orange-50 rounded">${res.category}</span>
                            <span class="text-xs text-slate-400 font-mono">${res.author}</span>
                        </div>
                        <h3 class="text-xl font-bold text-slate-900 mb-3">${res.title}</h3>
                        <p class="text-slate-600 text-sm mb-6 leading-relaxed">${res.desc}</p>
                        <div class="flex flex-wrap gap-2 mb-6">
                            ${tagHtml}
                        </div>
                    </div>
                    <a href="${res.link}" target="_blank" 
                       class="inline-flex items-center justify-center w-full px-4 py-2 bg-slate-900 text-white rounded-lg hover:bg-orange-700 transition-colors text-sm font-semibold">
                        Abrir Recurso 
                        <span class="ml-2">↗</span>
                    </a>
                `;
                grid.appendChild(card);
            });
        }

        function filterData(category) {
            currentFilter = category;
            
            // Actualizar botones
            document.querySelectorAll('.filter-btn').forEach(btn => {
                if (btn.textContent === category) {
                    btn.classList.replace('bg-slate-200', 'bg-slate-800');
                    btn.classList.replace('text-slate-600', 'text-white');
                } else {
                    btn.classList.replace('bg-slate-800', 'bg-slate-200');
                    btn.classList.replace('text-white', 'text-slate-600');
                }
            });

            const filtered = category === 'Todos' ? resources : resources.filter(r => r.category === category);
            renderResources(filtered);
        }

        // Buscador en tiempo real
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            const filtered = resources.filter(res => 
                res.title.toLowerCase().includes(term) || 
                res.desc.toLowerCase().includes(term) ||
                res.tags.some(t => t.toLowerCase().includes(term))
            );
            renderResources(filtered);
        });

        // Inicialización
        window.onload = () => renderResources(resources);
    </script>
</body>
</html>
